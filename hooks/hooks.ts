/**
 * Autogenerated TRX Hooks module from urn-cli
 *
 * @packageDocumentation
 */

import {urn_response} from 'urn-lib';

import * as uranio from '../cln/main';

let hook_token:string|undefined;
export function set_token(token:string):void{
	hook_token = token;
}

export const superusers = {
	authenticate: async (
		email: string,
		password: string
	): Promise<urn_response.General<uranio.types.Api.AuthResponse>> => {
		return await uranio.auth.create('superuser').authenticate(email, password);
	},
	count: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'superuser', 'count', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'superuser', 'count', D>>  => {
		const args:uranio.types.Hook.Arguments<'superuser', 'count', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('superuser',current_token).hook<'count',D>('count')(args);
	},
	find: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'superuser', 'find', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'superuser', 'find', D>>  => {
		const args:uranio.types.Hook.Arguments<'superuser', 'find', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('superuser',current_token).hook<'find',D>('find')(args);
	},
	find_id: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'superuser', 'find_id', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'superuser', 'find_id', D>>  => {
		const args:uranio.types.Hook.Arguments<'superuser', 'find_id', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('superuser',current_token).hook<'find_id',D>('find_id')(args);
	},
	find_one: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'superuser', 'find_one', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'superuser', 'find_one', D>>  => {
		const args:uranio.types.Hook.Arguments<'superuser', 'find_one', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('superuser',current_token).hook<'find_one',D>('find_one')(args);
	},
	insert: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'superuser', 'insert'>,
		options?:uranio.types.Hook.Arguments<'superuser', 'insert', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'superuser', 'insert', D>>  => {
		const args:uranio.types.Hook.Arguments<'superuser', 'insert', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('superuser',current_token).hook<'insert',D>('insert')(args);
	},
	update: async <D extends uranio.types.Depth>(
		id:string,
		body:uranio.types.Hook.Body<'superuser', 'update'>,
		options?:uranio.types.Hook.Arguments<'superuser', 'update', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'superuser', 'update', D>>  => {
		const args:uranio.types.Hook.Arguments<'superuser', 'update', D> = {
			params: {
				id: id,
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('superuser',current_token).hook<'update',D>('update')(args);
	},
	delete: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'superuser', 'delete', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'superuser', 'delete', D>>  => {
		const args:uranio.types.Hook.Arguments<'superuser', 'delete', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('superuser',current_token).hook<'delete',D>('delete')(args);
	},
	insert_multiple: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'superuser', 'insert_multiple'>,
		options?:uranio.types.Hook.Arguments<'superuser', 'insert_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'superuser', 'insert_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'superuser', 'insert_multiple', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('superuser',current_token).hook<'insert_multiple',D>('insert_multiple')(args);
	},
	update_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		body:uranio.types.Hook.Body<'superuser', 'update_multiple'>,
		options?:uranio.types.Hook.Arguments<'superuser', 'update_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'superuser', 'update_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'superuser', 'update_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('superuser',current_token).hook<'update_multiple',D>('update_multiple')(args);
	},
	delete_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		options?:uranio.types.Hook.Arguments<'superuser', 'delete_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'superuser', 'delete_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'superuser', 'delete_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('superuser',current_token).hook<'delete_multiple',D>('delete_multiple')(args);
	},
};
export const users = {
	authenticate: async (
		email: string,
		password: string
	): Promise<urn_response.General<uranio.types.Api.AuthResponse>> => {
		return await uranio.auth.create('user').authenticate(email, password);
	},
	count: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'user', 'count', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'user', 'count', D>>  => {
		const args:uranio.types.Hook.Arguments<'user', 'count', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('user',current_token).hook<'count',D>('count')(args);
	},
	find: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'user', 'find', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'user', 'find', D>>  => {
		const args:uranio.types.Hook.Arguments<'user', 'find', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('user',current_token).hook<'find',D>('find')(args);
	},
	find_id: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'user', 'find_id', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'user', 'find_id', D>>  => {
		const args:uranio.types.Hook.Arguments<'user', 'find_id', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('user',current_token).hook<'find_id',D>('find_id')(args);
	},
	find_one: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'user', 'find_one', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'user', 'find_one', D>>  => {
		const args:uranio.types.Hook.Arguments<'user', 'find_one', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('user',current_token).hook<'find_one',D>('find_one')(args);
	},
	insert: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'user', 'insert'>,
		options?:uranio.types.Hook.Arguments<'user', 'insert', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'user', 'insert', D>>  => {
		const args:uranio.types.Hook.Arguments<'user', 'insert', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('user',current_token).hook<'insert',D>('insert')(args);
	},
	update: async <D extends uranio.types.Depth>(
		id:string,
		body:uranio.types.Hook.Body<'user', 'update'>,
		options?:uranio.types.Hook.Arguments<'user', 'update', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'user', 'update', D>>  => {
		const args:uranio.types.Hook.Arguments<'user', 'update', D> = {
			params: {
				id: id,
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('user',current_token).hook<'update',D>('update')(args);
	},
	delete: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'user', 'delete', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'user', 'delete', D>>  => {
		const args:uranio.types.Hook.Arguments<'user', 'delete', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('user',current_token).hook<'delete',D>('delete')(args);
	},
	insert_multiple: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'user', 'insert_multiple'>,
		options?:uranio.types.Hook.Arguments<'user', 'insert_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'user', 'insert_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'user', 'insert_multiple', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('user',current_token).hook<'insert_multiple',D>('insert_multiple')(args);
	},
	update_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		body:uranio.types.Hook.Body<'user', 'update_multiple'>,
		options?:uranio.types.Hook.Arguments<'user', 'update_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'user', 'update_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'user', 'update_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('user',current_token).hook<'update_multiple',D>('update_multiple')(args);
	},
	delete_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		options?:uranio.types.Hook.Arguments<'user', 'delete_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'user', 'delete_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'user', 'delete_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('user',current_token).hook<'delete_multiple',D>('delete_multiple')(args);
	},
};
export const groups = {
	count: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'group', 'count', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'group', 'count', D>>  => {
		const args:uranio.types.Hook.Arguments<'group', 'count', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('group',current_token).hook<'count',D>('count')(args);
	},
	find: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'group', 'find', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'group', 'find', D>>  => {
		const args:uranio.types.Hook.Arguments<'group', 'find', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('group',current_token).hook<'find',D>('find')(args);
	},
	find_id: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'group', 'find_id', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'group', 'find_id', D>>  => {
		const args:uranio.types.Hook.Arguments<'group', 'find_id', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('group',current_token).hook<'find_id',D>('find_id')(args);
	},
	find_one: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'group', 'find_one', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'group', 'find_one', D>>  => {
		const args:uranio.types.Hook.Arguments<'group', 'find_one', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('group',current_token).hook<'find_one',D>('find_one')(args);
	},
	insert: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'group', 'insert'>,
		options?:uranio.types.Hook.Arguments<'group', 'insert', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'group', 'insert', D>>  => {
		const args:uranio.types.Hook.Arguments<'group', 'insert', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('group',current_token).hook<'insert',D>('insert')(args);
	},
	update: async <D extends uranio.types.Depth>(
		id:string,
		body:uranio.types.Hook.Body<'group', 'update'>,
		options?:uranio.types.Hook.Arguments<'group', 'update', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'group', 'update', D>>  => {
		const args:uranio.types.Hook.Arguments<'group', 'update', D> = {
			params: {
				id: id,
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('group',current_token).hook<'update',D>('update')(args);
	},
	delete: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'group', 'delete', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'group', 'delete', D>>  => {
		const args:uranio.types.Hook.Arguments<'group', 'delete', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('group',current_token).hook<'delete',D>('delete')(args);
	},
	insert_multiple: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'group', 'insert_multiple'>,
		options?:uranio.types.Hook.Arguments<'group', 'insert_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'group', 'insert_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'group', 'insert_multiple', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('group',current_token).hook<'insert_multiple',D>('insert_multiple')(args);
	},
	update_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		body:uranio.types.Hook.Body<'group', 'update_multiple'>,
		options?:uranio.types.Hook.Arguments<'group', 'update_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'group', 'update_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'group', 'update_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('group',current_token).hook<'update_multiple',D>('update_multiple')(args);
	},
	delete_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		options?:uranio.types.Hook.Arguments<'group', 'delete_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'group', 'delete_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'group', 'delete_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('group',current_token).hook<'delete_multiple',D>('delete_multiple')(args);
	},
};
export const media = {
	upload: async<D extends uranio.types.Depth>(
		file: Buffer | ArrayBuffer | Blob,
		token?: string
	): Promise<urn_response.General<uranio.types.Atom<'media'>>> => {
		let current_token: string | undefined;
		if (typeof hook_token === "string" && hook_token !== "") {
			current_token = hook_token;
		}
		if (typeof token === "string" && token !== "") {
			current_token = token;
		}
		return await uranio.media.create(current_token).upload<D>(file, current_token);
	},
	presigned: async(
		filename: string,
		size?: number,
		type?: string,
		token?: string
	): Promise<urn_response.General<string>> => {
		let current_token: string | undefined;
		if (typeof hook_token === "string" && hook_token !== "") {
			current_token = hook_token;
		}
		if (typeof token === "string" && token !== "") {
			current_token = token;
		}
		return await uranio.media.create(current_token).presigned(filename, size, type, current_token);
	},
	count: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'media', 'count', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'media', 'count', D>>  => {
		const args:uranio.types.Hook.Arguments<'media', 'count', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('media',current_token).hook<'count',D>('count')(args);
	},
	find: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'media', 'find', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'media', 'find', D>>  => {
		const args:uranio.types.Hook.Arguments<'media', 'find', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('media',current_token).hook<'find',D>('find')(args);
	},
	find_id: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'media', 'find_id', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'media', 'find_id', D>>  => {
		const args:uranio.types.Hook.Arguments<'media', 'find_id', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('media',current_token).hook<'find_id',D>('find_id')(args);
	},
	find_one: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'media', 'find_one', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'media', 'find_one', D>>  => {
		const args:uranio.types.Hook.Arguments<'media', 'find_one', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('media',current_token).hook<'find_one',D>('find_one')(args);
	},
	insert: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'media', 'insert'>,
		options?:uranio.types.Hook.Arguments<'media', 'insert', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'media', 'insert', D>>  => {
		const args:uranio.types.Hook.Arguments<'media', 'insert', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('media',current_token).hook<'insert',D>('insert')(args);
	},
	update: async <D extends uranio.types.Depth>(
		id:string,
		body:uranio.types.Hook.Body<'media', 'update'>,
		options?:uranio.types.Hook.Arguments<'media', 'update', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'media', 'update', D>>  => {
		const args:uranio.types.Hook.Arguments<'media', 'update', D> = {
			params: {
				id: id,
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('media',current_token).hook<'update',D>('update')(args);
	},
	delete: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'media', 'delete', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'media', 'delete', D>>  => {
		const args:uranio.types.Hook.Arguments<'media', 'delete', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('media',current_token).hook<'delete',D>('delete')(args);
	},
	insert_multiple: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'media', 'insert_multiple'>,
		options?:uranio.types.Hook.Arguments<'media', 'insert_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'media', 'insert_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'media', 'insert_multiple', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('media',current_token).hook<'insert_multiple',D>('insert_multiple')(args);
	},
	update_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		body:uranio.types.Hook.Body<'media', 'update_multiple'>,
		options?:uranio.types.Hook.Arguments<'media', 'update_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'media', 'update_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'media', 'update_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('media',current_token).hook<'update_multiple',D>('update_multiple')(args);
	},
	delete_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		options?:uranio.types.Hook.Arguments<'media', 'delete_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'media', 'delete_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'media', 'delete_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('media',current_token).hook<'delete_multiple',D>('delete_multiple')(args);
	},
};
export const settings = {
	count: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'setting', 'count', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'setting', 'count', D>>  => {
		const args:uranio.types.Hook.Arguments<'setting', 'count', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('setting',current_token).hook<'count',D>('count')(args);
	},
	find: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'setting', 'find', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'setting', 'find', D>>  => {
		const args:uranio.types.Hook.Arguments<'setting', 'find', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('setting',current_token).hook<'find',D>('find')(args);
	},
	find_id: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'setting', 'find_id', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'setting', 'find_id', D>>  => {
		const args:uranio.types.Hook.Arguments<'setting', 'find_id', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('setting',current_token).hook<'find_id',D>('find_id')(args);
	},
	find_one: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'setting', 'find_one', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'setting', 'find_one', D>>  => {
		const args:uranio.types.Hook.Arguments<'setting', 'find_one', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('setting',current_token).hook<'find_one',D>('find_one')(args);
	},
	insert: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'setting', 'insert'>,
		options?:uranio.types.Hook.Arguments<'setting', 'insert', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'setting', 'insert', D>>  => {
		const args:uranio.types.Hook.Arguments<'setting', 'insert', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('setting',current_token).hook<'insert',D>('insert')(args);
	},
	update: async <D extends uranio.types.Depth>(
		id:string,
		body:uranio.types.Hook.Body<'setting', 'update'>,
		options?:uranio.types.Hook.Arguments<'setting', 'update', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'setting', 'update', D>>  => {
		const args:uranio.types.Hook.Arguments<'setting', 'update', D> = {
			params: {
				id: id,
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('setting',current_token).hook<'update',D>('update')(args);
	},
	delete: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'setting', 'delete', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'setting', 'delete', D>>  => {
		const args:uranio.types.Hook.Arguments<'setting', 'delete', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('setting',current_token).hook<'delete',D>('delete')(args);
	},
	insert_multiple: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'setting', 'insert_multiple'>,
		options?:uranio.types.Hook.Arguments<'setting', 'insert_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'setting', 'insert_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'setting', 'insert_multiple', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('setting',current_token).hook<'insert_multiple',D>('insert_multiple')(args);
	},
	update_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		body:uranio.types.Hook.Body<'setting', 'update_multiple'>,
		options?:uranio.types.Hook.Arguments<'setting', 'update_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'setting', 'update_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'setting', 'update_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('setting',current_token).hook<'update_multiple',D>('update_multiple')(args);
	},
	delete_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		options?:uranio.types.Hook.Arguments<'setting', 'delete_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'setting', 'delete_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'setting', 'delete_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('setting',current_token).hook<'delete_multiple',D>('delete_multiple')(args);
	},
};
export const errors = {
	count: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'error', 'count', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'error', 'count', D>>  => {
		const args:uranio.types.Hook.Arguments<'error', 'count', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('error',current_token).hook<'count',D>('count')(args);
	},
	find: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'error', 'find', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'error', 'find', D>>  => {
		const args:uranio.types.Hook.Arguments<'error', 'find', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('error',current_token).hook<'find',D>('find')(args);
	},
	find_id: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'error', 'find_id', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'error', 'find_id', D>>  => {
		const args:uranio.types.Hook.Arguments<'error', 'find_id', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('error',current_token).hook<'find_id',D>('find_id')(args);
	},
	find_one: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'error', 'find_one', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'error', 'find_one', D>>  => {
		const args:uranio.types.Hook.Arguments<'error', 'find_one', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('error',current_token).hook<'find_one',D>('find_one')(args);
	},
	insert: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'error', 'insert'>,
		options?:uranio.types.Hook.Arguments<'error', 'insert', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'error', 'insert', D>>  => {
		const args:uranio.types.Hook.Arguments<'error', 'insert', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('error',current_token).hook<'insert',D>('insert')(args);
	},
	update: async <D extends uranio.types.Depth>(
		id:string,
		body:uranio.types.Hook.Body<'error', 'update'>,
		options?:uranio.types.Hook.Arguments<'error', 'update', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'error', 'update', D>>  => {
		const args:uranio.types.Hook.Arguments<'error', 'update', D> = {
			params: {
				id: id,
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('error',current_token).hook<'update',D>('update')(args);
	},
	delete: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'error', 'delete', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'error', 'delete', D>>  => {
		const args:uranio.types.Hook.Arguments<'error', 'delete', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('error',current_token).hook<'delete',D>('delete')(args);
	},
	insert_multiple: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'error', 'insert_multiple'>,
		options?:uranio.types.Hook.Arguments<'error', 'insert_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'error', 'insert_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'error', 'insert_multiple', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('error',current_token).hook<'insert_multiple',D>('insert_multiple')(args);
	},
	update_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		body:uranio.types.Hook.Body<'error', 'update_multiple'>,
		options?:uranio.types.Hook.Arguments<'error', 'update_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'error', 'update_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'error', 'update_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('error',current_token).hook<'update_multiple',D>('update_multiple')(args);
	},
	delete_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		options?:uranio.types.Hook.Arguments<'error', 'delete_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'error', 'delete_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'error', 'delete_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('error',current_token).hook<'delete_multiple',D>('delete_multiple')(args);
	},
};
export const requests = {
	count: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'request', 'count', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'request', 'count', D>>  => {
		const args:uranio.types.Hook.Arguments<'request', 'count', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('request',current_token).hook<'count',D>('count')(args);
	},
	find: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'request', 'find', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'request', 'find', D>>  => {
		const args:uranio.types.Hook.Arguments<'request', 'find', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('request',current_token).hook<'find',D>('find')(args);
	},
	find_id: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'request', 'find_id', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'request', 'find_id', D>>  => {
		const args:uranio.types.Hook.Arguments<'request', 'find_id', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('request',current_token).hook<'find_id',D>('find_id')(args);
	},
	find_one: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'request', 'find_one', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'request', 'find_one', D>>  => {
		const args:uranio.types.Hook.Arguments<'request', 'find_one', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('request',current_token).hook<'find_one',D>('find_one')(args);
	},
	insert: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'request', 'insert'>,
		options?:uranio.types.Hook.Arguments<'request', 'insert', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'request', 'insert', D>>  => {
		const args:uranio.types.Hook.Arguments<'request', 'insert', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('request',current_token).hook<'insert',D>('insert')(args);
	},
	update: async <D extends uranio.types.Depth>(
		id:string,
		body:uranio.types.Hook.Body<'request', 'update'>,
		options?:uranio.types.Hook.Arguments<'request', 'update', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'request', 'update', D>>  => {
		const args:uranio.types.Hook.Arguments<'request', 'update', D> = {
			params: {
				id: id,
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('request',current_token).hook<'update',D>('update')(args);
	},
	delete: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'request', 'delete', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'request', 'delete', D>>  => {
		const args:uranio.types.Hook.Arguments<'request', 'delete', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('request',current_token).hook<'delete',D>('delete')(args);
	},
	insert_multiple: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'request', 'insert_multiple'>,
		options?:uranio.types.Hook.Arguments<'request', 'insert_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'request', 'insert_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'request', 'insert_multiple', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('request',current_token).hook<'insert_multiple',D>('insert_multiple')(args);
	},
	update_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		body:uranio.types.Hook.Body<'request', 'update_multiple'>,
		options?:uranio.types.Hook.Arguments<'request', 'update_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'request', 'update_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'request', 'update_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('request',current_token).hook<'update_multiple',D>('update_multiple')(args);
	},
	delete_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		options?:uranio.types.Hook.Arguments<'request', 'delete_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'request', 'delete_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'request', 'delete_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('request',current_token).hook<'delete_multiple',D>('delete_multiple')(args);
	},
};
export const customers = {
	count: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'customer', 'count', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'customer', 'count', D>>  => {
		const args:uranio.types.Hook.Arguments<'customer', 'count', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('customer',current_token).hook<'count',D>('count')(args);
	},
	hello: async <D extends uranio.types.Depth>(
		stocazzo:string,
		options?:uranio.types.Hook.Arguments<'customer', 'hello', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'customer', 'hello', D>>  => {
		const args:uranio.types.Hook.Arguments<'customer', 'hello', D> = {
			params: {
				stocazzo: stocazzo,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('customer',current_token).hook<'hello',D>('hello')(args);
	},
	find: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'customer', 'find', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'customer', 'find', D>>  => {
		const args:uranio.types.Hook.Arguments<'customer', 'find', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('customer',current_token).hook<'find',D>('find')(args);
	},
	find_id: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'customer', 'find_id', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'customer', 'find_id', D>>  => {
		const args:uranio.types.Hook.Arguments<'customer', 'find_id', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('customer',current_token).hook<'find_id',D>('find_id')(args);
	},
	find_one: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'customer', 'find_one', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'customer', 'find_one', D>>  => {
		const args:uranio.types.Hook.Arguments<'customer', 'find_one', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('customer',current_token).hook<'find_one',D>('find_one')(args);
	},
	insert: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'customer', 'insert'>,
		options?:uranio.types.Hook.Arguments<'customer', 'insert', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'customer', 'insert', D>>  => {
		const args:uranio.types.Hook.Arguments<'customer', 'insert', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('customer',current_token).hook<'insert',D>('insert')(args);
	},
	update: async <D extends uranio.types.Depth>(
		id:string,
		body:uranio.types.Hook.Body<'customer', 'update'>,
		options?:uranio.types.Hook.Arguments<'customer', 'update', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'customer', 'update', D>>  => {
		const args:uranio.types.Hook.Arguments<'customer', 'update', D> = {
			params: {
				id: id,
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('customer',current_token).hook<'update',D>('update')(args);
	},
	delete: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'customer', 'delete', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'customer', 'delete', D>>  => {
		const args:uranio.types.Hook.Arguments<'customer', 'delete', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('customer',current_token).hook<'delete',D>('delete')(args);
	},
	insert_multiple: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'customer', 'insert_multiple'>,
		options?:uranio.types.Hook.Arguments<'customer', 'insert_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'customer', 'insert_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'customer', 'insert_multiple', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('customer',current_token).hook<'insert_multiple',D>('insert_multiple')(args);
	},
	update_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		body:uranio.types.Hook.Body<'customer', 'update_multiple'>,
		options?:uranio.types.Hook.Arguments<'customer', 'update_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'customer', 'update_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'customer', 'update_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('customer',current_token).hook<'update_multiple',D>('update_multiple')(args);
	},
	delete_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		options?:uranio.types.Hook.Arguments<'customer', 'delete_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'customer', 'delete_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'customer', 'delete_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('customer',current_token).hook<'delete_multiple',D>('delete_multiple')(args);
	},
};
export const mykarts = {
	count: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'mykart', 'count', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'mykart', 'count', D>>  => {
		const args:uranio.types.Hook.Arguments<'mykart', 'count', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('mykart',current_token).hook<'count',D>('count')(args);
	},
	find: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'mykart', 'find', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'mykart', 'find', D>>  => {
		const args:uranio.types.Hook.Arguments<'mykart', 'find', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('mykart',current_token).hook<'find',D>('find')(args);
	},
	find_id: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'mykart', 'find_id', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'mykart', 'find_id', D>>  => {
		const args:uranio.types.Hook.Arguments<'mykart', 'find_id', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('mykart',current_token).hook<'find_id',D>('find_id')(args);
	},
	find_one: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'mykart', 'find_one', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'mykart', 'find_one', D>>  => {
		const args:uranio.types.Hook.Arguments<'mykart', 'find_one', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('mykart',current_token).hook<'find_one',D>('find_one')(args);
	},
	insert: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'mykart', 'insert'>,
		options?:uranio.types.Hook.Arguments<'mykart', 'insert', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'mykart', 'insert', D>>  => {
		const args:uranio.types.Hook.Arguments<'mykart', 'insert', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('mykart',current_token).hook<'insert',D>('insert')(args);
	},
	update: async <D extends uranio.types.Depth>(
		id:string,
		body:uranio.types.Hook.Body<'mykart', 'update'>,
		options?:uranio.types.Hook.Arguments<'mykart', 'update', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'mykart', 'update', D>>  => {
		const args:uranio.types.Hook.Arguments<'mykart', 'update', D> = {
			params: {
				id: id,
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('mykart',current_token).hook<'update',D>('update')(args);
	},
	delete: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'mykart', 'delete', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'mykart', 'delete', D>>  => {
		const args:uranio.types.Hook.Arguments<'mykart', 'delete', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('mykart',current_token).hook<'delete',D>('delete')(args);
	},
	insert_multiple: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'mykart', 'insert_multiple'>,
		options?:uranio.types.Hook.Arguments<'mykart', 'insert_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'mykart', 'insert_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'mykart', 'insert_multiple', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('mykart',current_token).hook<'insert_multiple',D>('insert_multiple')(args);
	},
	update_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		body:uranio.types.Hook.Body<'mykart', 'update_multiple'>,
		options?:uranio.types.Hook.Arguments<'mykart', 'update_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'mykart', 'update_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'mykart', 'update_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('mykart',current_token).hook<'update_multiple',D>('update_multiple')(args);
	},
	delete_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		options?:uranio.types.Hook.Arguments<'mykart', 'delete_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'mykart', 'delete_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'mykart', 'delete_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('mykart',current_token).hook<'delete_multiple',D>('delete_multiple')(args);
	},
};
export const products = {
	count: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'product', 'count', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'product', 'count', D>>  => {
		const args:uranio.types.Hook.Arguments<'product', 'count', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('product',current_token).hook<'count',D>('count')(args);
	},
	myroute: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'product', 'myroute', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'product', 'myroute', D>>  => {
		const args:uranio.types.Hook.Arguments<'product', 'myroute', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('product',current_token).hook<'myroute',D>('myroute')(args);
	},
	find: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'product', 'find', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'product', 'find', D>>  => {
		const args:uranio.types.Hook.Arguments<'product', 'find', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('product',current_token).hook<'find',D>('find')(args);
	},
	find_id: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'product', 'find_id', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'product', 'find_id', D>>  => {
		const args:uranio.types.Hook.Arguments<'product', 'find_id', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('product',current_token).hook<'find_id',D>('find_id')(args);
	},
	find_one: async <D extends uranio.types.Depth>(
		options?:uranio.types.Hook.Arguments<'product', 'find_one', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'product', 'find_one', D>>  => {
		const args:uranio.types.Hook.Arguments<'product', 'find_one', D> = {
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('product',current_token).hook<'find_one',D>('find_one')(args);
	},
	insert: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'product', 'insert'>,
		options?:uranio.types.Hook.Arguments<'product', 'insert', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'product', 'insert', D>>  => {
		const args:uranio.types.Hook.Arguments<'product', 'insert', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('product',current_token).hook<'insert',D>('insert')(args);
	},
	update: async <D extends uranio.types.Depth>(
		id:string,
		body:uranio.types.Hook.Body<'product', 'update'>,
		options?:uranio.types.Hook.Arguments<'product', 'update', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'product', 'update', D>>  => {
		const args:uranio.types.Hook.Arguments<'product', 'update', D> = {
			params: {
				id: id,
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('product',current_token).hook<'update',D>('update')(args);
	},
	delete: async <D extends uranio.types.Depth>(
		id:string,
		options?:uranio.types.Hook.Arguments<'product', 'delete', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'product', 'delete', D>>  => {
		const args:uranio.types.Hook.Arguments<'product', 'delete', D> = {
			params: {
				id: id,
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('product',current_token).hook<'delete',D>('delete')(args);
	},
	insert_multiple: async <D extends uranio.types.Depth>(
		body:uranio.types.Hook.Body<'product', 'insert_multiple'>,
		options?:uranio.types.Hook.Arguments<'product', 'insert_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'product', 'insert_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'product', 'insert_multiple', D> = {
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('product',current_token).hook<'insert_multiple',D>('insert_multiple')(args);
	},
	update_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		body:uranio.types.Hook.Body<'product', 'update_multiple'>,
		options?:uranio.types.Hook.Arguments<'product', 'update_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'product', 'update_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'product', 'update_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			body: body,
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('product',current_token).hook<'update_multiple',D>('update_multiple')(args);
	},
	delete_multiple: async <D extends uranio.types.Depth>(
		ids:string[],
		options?:uranio.types.Hook.Arguments<'product', 'delete_multiple', D>,
		token?:string
	):Promise<uranio.types.Hook.Response<'product', 'delete_multiple', D>>  => {
		const args:uranio.types.Hook.Arguments<'product', 'delete_multiple', D> = {
			params: {
				ids: ids.join(',')
			},
			...options
		};
		let current_token:string|undefined;
		if(typeof hook_token === 'string' && hook_token !== ''){
			current_token = hook_token;
		}
		if(typeof token === 'string' && token !== ''){
			current_token = token;
		}
		return await uranio.base.create('product',current_token).hook<'delete_multiple',D>('delete_multiple')(args);
	},
};
